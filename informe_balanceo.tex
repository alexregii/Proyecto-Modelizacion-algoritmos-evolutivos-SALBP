\documentclass[12pt]{report}

\title{Proyecto de modelización - Programación evolutiva\\ \textbf{El problema de balanceo de líneas de montaje}} 
\author{Paul Rohel - Alejandro Regidor Orellana}
\date{\today}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{mathtools, amsfonts, amssymb, amsthm}
\usepackage{float}

\renewcommand{\chaptername}{}

\setlength{\parindent}{0pt}

\makeatletter
\renewcommand{\@makechapterhead}[1]{\vspace*{50\p@}%
  \begin{center}%
    {\normalfont\huge\bfseries #1\par}%
  \end{center}\vskip 40\p@}
\makeatother

\begin{document}

\maketitle
\tableofcontents

\chapter{Planteamiento del problema}

El problema de balanceo de líneas de ensamblaje puede plantearse de diferentes maneras.Dadas $n$ tareas, cada una con un tiempo de procesamiento asignado y una lista de relaciones de precedencia entre ellas, dichas tareas deben asignarse a $m \leq n$ estaciones de trabajo.\\
Una de las variantes clásicas, conocida como \textit{Simple Assembly Line Balancing Problem tipo 1} (SALBP-1), consiste en encontrar una asignación de las $n$ tareas a las estaciones de manera que se minimice el número de estaciones, dado un tiempo de ciclo preestablecido.\\
En cambio, la variante sobre la que hemos trabajado (SALBP-2) tiene como objetivo encontrar una asignación de tareas que minimice el tiempo de ciclo, dado un número fijo de estaciones $m$. En este contexto, el tiempo de ciclo se define como el tiempo total más largo asignado a una estación, es decir, el máximo entre todas las estaciones.

\chapter{Presentación general del algoritmo genético}

Para resolver este problema, implementamos un algoritmo genético. 
Dadas $n$ tareas que deben asignarse a $m$ estaciones, el espacio de búsqueda contiene $O\left(\binom{n}{m}\right)$ soluciones posibles. 
Una solución, es decir, una asignación de las tareas entre las diferentes estaciones, se codifica posicionalmente como un arreglo unidimensional indexado de $0$ a $n-1$, 
cuyos elementos toman valores enteros entre $0$ y $m-1$.

Por ejemplo, el arreglo $[0, 0, 0, 1, 0, 2, 2, 1]$ representa una solución para un problema con $8$ tareas distribuidas en $3$ estaciones.\\

Para codificar las relaciones de precedencia entre las tareas, utilizamos una matriz $A$ de tamaño $n \times n$ definida de la siguiente manera:\\
$
\forall i,j \in \{0,\dots,n-1\},$\\
$
A(i,j) = 
\begin{cases}
1 & \text{si la tarea } j \text{ precede directamente a la tarea } i \\
0 & \text{en caso contrario}
\end{cases}
$\\

Dado que todas las tareas que deben preceder a otra deben asignarse a una estación anterior o, como máximo, a la misma estación que la tarea que las sigue, 
las relaciones de precedencia imponen restricciones estrictas sobre la validez de las soluciones. También es necesario verificar que exactamente todos los grupos dados, y solo esos, aparezcan en los valores del arreglo solución.\\

La función de evaluación de un individuo consiste, esencialmente, en devolver el mayor tiempo entre estaciones. Por lo tanto, el objetivo del problema es encontrar el individuo que minimice dicha función, penalizando a aquellos que no cumplen con las restricciones previamente establecidas.\\

La principal dificultad que enfrentamos en este trabajo fue la gestión de la diversidad de los individuos: encontrar un equilibrio entre una selección demasiado estricta, que conduce a una convergencia hacia un mínimo local, y una selección demasiado permisiva, que favorece en exceso la generación de individuos no válidos.

\chapter{Génesis detallada del algoritmo}

\section{Generación de una población inicial}

Una población inicial es generada por la función \textit{población inicial}. Una población consiste simplemente en un arreglo de soluciones, cuya dimensión está determinada por el parámetro $dim\_pob$.

\subsection*{Generar individuos aleatorios}

Para llenar una población, nuestro primer enfoque fue generar individuos completamente aleatorios, sin tener cuenta de las restricciones. Suponíamos que, dado que nuestra función de evaluación penalizaba con un valor arbitrariamente alto a los individuos no válidos, acabaríamos, tras algunas generaciones, con una población compuesta mayoritariamente por individuos válidos.\\

Sin embargo, las restricciones del problema eran tan estrictas que, incluso con grafos de apenas $6$ tareas con tiempos relativamente equilibrados y distribuidas en $3$ estaciones, obteníamos poblaciones con un $90\%$ de individuos no válidos.
Esta minoría de individuos válidos no era suficiente para permitir que el algoritmo avanzara hacia algún punto estacionario.

\subsection*{Generar individuos aleatorios hasta que cumplen las restricciones}

Nuestro segundo enfoque consistió entonces en seguir generando individuos completamente aleatorios, hasta que cumplieran con las restricciones del problema, para luego añadirlos a la población.\\

La verificación de las restricciones está a cargo de la función booleana \textit{condiciones}, que devuelve falso si un individuo \textit{sec} no contiene exactamente —y únicamente— valores entre $0$ y $m-1$, o si existe una relación de precedencia directa entre dos estaciones, especificada en la matriz correspondiente \textit{A}, que no se respeta en el individuo. Es decir, si:
\[
\exists i,j \in \{0,\dots,n-1\} \text{ tal que } A(i,j) = 1 \text{ y } sec[i] < sec[j]
\]

Sin embargo, el principal defecto de este enfoque se hizo evidente muy rápidamente: se necesitaba un número extremadamente alto de iteraciones para generar siquiera un solo individuo válido para la población.
El algoritmo resultaba entonces especialmente lento, al punto de no llegar siquiera a completar la primera generación.

\subsection*{Generar individuos mediante orden topológico}

Con el fin de generar individuos con mayor probabilidad de cumplir con todas las restricciones, utilizamos la noción de orden topológico: un orden lineal —entre varios posibles— de los nodos de un grafo dirigido acíclico, representado en nuestro caso por la matriz de precedencia $A$. \\
Utilizamos la función $topological\_sort$ de la biblioteca $networkx$ para extraer un orden topológico del grafo derivado de $A$ (véase la función $matriz\_a\_ \\ lista\_adyacencia$).\\

De hecho, para cada individuo, la primera tarea en el orden topológico se asigna a la última estación $m-1$. Luego, para cada tarea siguiente ($ord\_top[i]$), se elige aleatoriamente (mediante $random.randint()$) una estación en función de la tarea anterior ($ord\_top[i-1]$), de manera que no comience después que esta: la misma estación o la inmediatamente anterior. \\

Este enfoque nos permitió obtener un primer algoritmo funcional, pero presenta una limitación importante relacionada con la sobrecarga de la estación $0$. \\
En efecto, durante la construcción de un individuo, la probabilidad de asignar una estación anterior con respecto a la tarea precedente es del $50\%$. Esto provoca un descenso rápido hacia la estación $0$, donde ya no es posible asignar estaciones más bajas. Como resultado, las tareas siguientes tienden a acumularse en dicha estación.\\

Como resultado, nos enfrentamos a un problema de convergencia prematura. Todas las soluciones generadas eran muy similares entre sí, presentando sistemáticamente la sobrecarga de la estación $0$, y el algoritmo exploraba únicamente una porción muy limitada del espacio de soluciones posibles.


\subsection*{Uniformización de la distribución de las estaciones}

Con el fin de paliar la sobrecarga de la primera estación, reemplazamos el muestreo equiprobable mediante $random.randint()$ por un muestreo que permite uniformizar al máximo la distribución de las tareas entre las estaciones.\\

Durante la generación de un individuo siguiendo un orden topológico, la probabilidad de que una tarea pertenezca a la estación anterior a la de la tarea precedente es $p$; la probabilidad de que pertenezca a la misma estación es $0.99 - p$; y la de que pertenezca a la estación siguiente es $0.01$.\\ 

Después de varias pruebas, vimos que el valor óptimo de $p$ no puede determinarse de forma arbitraria y que debe calcularse en función del número de estaciones y de tareas del problema (ver archivo $bestp.py$).\\
Simulamos un proceso aleatorio en el que una posición evoluciona a lo largo de una cadena de $m$ etapas, avanzando con una probabilidad p en cada iteración, durante $n$ pasos. La función $simulate\_chain$ repite esta simulación $num\_runs = 1000$ veces para estimar la frecuencia con la que se ocupa cada posición. Luego, $find\_best\_p$ busca el valor de $p$ que hace que esta distribución sea lo más uniforme posible, comparando la distribución obtenida con una distribución perfectamente uniforme y minimizando el error cuadrático.

\subsection*{Combinación de los modos de generación}

Aunque el modelo de generación de individuos siguiendo un orden topológico haya sido uniformizado, este sigue llevando a una estancación del algoritmo en un mínimo local.\\

Para introducir una mayor diversidad a lo largo de las generaciones, decidimos generar una parte de la población de forma completamente aleatoria, sin restricciones. Tras varias pruebas, parece que la proporción óptima entre individuos generados por ambos modos es del $50\%$.\\

Asociado a una función de evaluación que asigna una puntuación no arbitraria a los individuos no válidos, el algoritmo se acerca más a la solución exacta del problema. Para una cantidad de individuos generados inferior al $10\%$ del tamaño del espacio de búsqueda en el caso de los grafos más pequeños, o incluso al $10\,000\%$ para los más grandes, la solución calculada presenta un tiempo de ciclo que, en la mayoría de los casos, se sitúa alrededor de un $5\%$ por encima del valor de la solución óptima.\\

La incorporación de una variación aleatoria de los órdenes topológicos extraídos de $A$ en el modelo no parece ser particularmente eficaz, ya que conduce a resultados que no son mejores.

\section{Función de evaluación}

La función de evaluación $score$ está definida por: \\
\[
f(\text{individuo}) = 0.6 \cdot \text{tiempo de ciclo} + 0.2 \cdot \text{dispersión} + 0.1 \cdot \text{n\_fallos} \cdot \text{media}
\]
con:\\
\begin{itemize}
\item tiempo de ciclo : el tiempo máximo asignado a una estación.
\item dispersión : una medida del equilibrio del tiempo entre las estaciones,\\
igual a la diferencia entre el tiempo de ciclo y el tiempo mínimo asignado a una estación.
\item $\text{n\_fallos}$ : el número de tareas que no respetan las restricciones del problema.
\item media : el promedio de los tiempos entre las estaciones.
\end{itemize}

El ajuste de los coeficientes asociados a los términos de la función se determinó empíricamente. Asociados a nuestros mecanismos de selección y generación de la población inicial, permiten que el algoritmo avance lo más lejos posible hacia la solución exacta del problema.\\

El peso asociado al tiempo de ciclo es el más alto, ya que es precisamente esta medida la que nos interesa en este problema y que buscamos minimizar.\\

Decidimos integrar una medida del equilibrio de los tiempos entre las estaciones (la dispersión) por dos razones.\\
La primera es que, al inicio de nuestro trabajo, debido a una mala interpretación del problema, definimos nuestra función de evaluación únicamente como una medida de equilibrio. Sin embargo, constatamos que resultaba relativamente eficaz, contribuyendo a la minimización del tiempo de ciclo.\\
La segunda razón es que la inclusión de esta segunda medida permite valorar ciertos individuos portadores de estructuras potencialmente favorables para la reducción del tiempo de ciclo, aunque este último los penalice. Esto contribuye a favorecer la diversidad de los individuos válidos, lidos, una característica que buscamos maximizar para que el algoritmo no se estanque en un mínimo local.\\

El término de penalización para los individuos no válidos (\(\text{n\_fallos} \times \text{media}\)) permite favorecer a aquellos individuos no válidos que violan menos restricciones en comparación con aquellos que las violan en mayor medida. Esto permite discriminar razonablemente entre individuos válidos y no válidos, al mismo tiempo que permite la reproducción de individuos que no necesariamente siguen el orden topológico definido durante la generación de la población.

Hemos elegido multiplicar el número de violaciones de las restricciones por la media de los tiempos de las estaciones, con el fin de obtener un término de penalización que se ajuste propocionalmente a la escala de cada grafo considerado.

\end{document}
